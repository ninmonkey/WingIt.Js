<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WingIt.Js - Seek Mouse Behavior</title>
    <link rel="stylesheet" href="./css/main.css" type="text/css">
</head>

<body>
    <section>
        <nav>
            <ul>
                <li><a href="./">Go Back</a></li>
                <!-- <li><a href="#" id="cmd-btn-toggle-grid-large">Large / Small</a></li> -->
            </ul>
        </nav>
    </section>
    <h1>Seek Mouse Clicks Behavior: using constant acceleration</h1>
    <section id="cmd-bar">
        <button id="btn-draw-vector">Show Vectors</button>
        <button id="btn-disable-steer">Disable Steering</button>
        <br/>
        <label for="max-init-velocity">Maximum initial velocity: </label>
<input
        type  = "range"
        name  = "max-init-velocity"
        id    = "max-init-velocity"
        max   = "7"
        min   = "0.00001"
        step  = "0.00001"
        value = "3.4" />
<output class = "max-init-velocity-output" for = "max-init-velocity"></output>
        <!-- value = 1.8, "0.01" /> -->
        <br/>
        <label for="max-steer-force">Max Steering: </label>
<input
        type  = "range"
        name  = "max-steer-force"
        id    = "max-steer-force"
        max   = "5.0"
        min   = "0.0000001"
        step  = "0.000001"
        value = "4.0" />
        <!-- value: 2.8, 0.1, 0.00001 -->


<output class = "max-steer-force-output" for = "max-steer-force"></output>
        <br/>
        <label for="max-velocity-force">Max Velocity: </label>
<input
        type  = "range"
        name  = "max-velocity-force"
        id    = "max-velocity-force"
        max   = "3"
        min   = "0.0000001"
        step  = "0.00001"
        value = "2.0" />

        <!-- value:  1.5, 0.1, 0.00001 -->

<output class = "max-velocity-force-output" for = "max-velocity-force"></output>
<!-- 0.00001
 0.0001
 0.001
 0.01 -->
    </section>
    <section class="canvas-parent parent-context grid-small">

        <canvas id="canvas" width="800px" height="600px"></canvas>

    </section>

    <script type="module">
        import { randomInt, randomNumber, toDegrees, toRadians, randomAngle, randomAngleOffset } from './../../js/utils.js';
        import {
            Boid,
            BounceScreenEdge,
            debugLogBoidStates,
            TestIsOnScreen,
            Vector2,
            WrapScreenEdge,
        } from './../../js/boid.js';
        import { labelPoint, drawVector, drawVectorAngle } from './../../js/drawing.js';
        // globals
        const appConfig = {
            spawnCount: 7,
            spawnWithMass: false, // does random velocity takes radius into account?
            alwaysClearScreen: true,
            drawVectors: true,
            lastMousePos: new Vector2( 200, 200 ),
            maxSteerForce: 0.02,
            spawnMaxVelocity: 0.01,
            maxVelocityForce: 0.1,
            disableSeeking: false,
        }
        window.bag ??= {}
        window.toDeg = toDegrees
        window.toRad = toRadians

        let entityList = Array.from( [] )

        const canvas = document.getElementById( "canvas" );
        const ctx = canvas.getContext( "2d" );
        const color_clear_canvas = "#464746";
        const color_boid_fill = "rgb(27, 151, 182)";
        const color_velocity = 'rgb(27 151 182 / .6)'
        const color_steer = 'rgb(160 100 100 / .9)'

        let start

        function drawCanvas () {
            if ( appConfig.alwaysClearScreen ) {
                ctx.clearRect( 0, 0, screen.width, screen.height )
            }

            for ( const ent of entityList ) {
                if( appConfig.drawVectors ) {
                    const drawVel = ent.Velocity.clone().scale(50).limit(100)
                    const drawSteer = ent.Steer.clone().normalize().scale(50).limit(100)
                    drawVector( ctx, ent.Position, drawSteer, color_steer ) // steering
                    drawVector( ctx, ent.Position, drawVel, color_velocity ) // velocity
                }
                // drawVector( ctx, ent.Position, relPos, color_velocity ) // velocity
                // drawVector( ctx, ent.Position, ent.Velocity.angle(), ent.Velocity.magnitude() * 10, color_velocity ) // velocity
                // drawVectorAngle( ctx, ent.Position, toRadians( 45 ), 70, color_velocity ) // heading
                // drawVectorAngle( ctx, ent.Position, toRadians( 45 ), 60, color_steer ) // heading
                ent.draw( ctx )
                // drawVector( ctx, { x: 10, y: 10  }, toRadians( -90 ), 10, 'green' )
            }

            // draw target
              ctx.beginPath();

            // ctx.fillStyle = 'red'
            ctx.strokeStyle = 'hsl(200 100% 50% / .75)'
            ctx.fillStyle = 'hsl(10 30% 50% / .7'
            ctx.lineWidth = 4
            ctx.strokeStyle = 'hsl(0 0% 0% / 0.3)'
            ctx.arc( appConfig.lastMousePos.x, appConfig.lastMousePos.y, 10,
                /* startAngle */ 0, /* end angle */  Math.PI * 2, true );
            ctx.stroke()
            ctx.fill()

        }
        function InitializePage () {
            let i
            const randAngle = randomAngle()
            const maxVel = appConfig.spawnMaxVelocity ?? .003

            entityList = []; // clear the array before spawning new entities

            for ( i = 0; i < appConfig.spawnCount; i++ ) {
                const b = new Boid()

                b.Radius = randomInt( 10, 30 )
                b.Position.fromCoord(
                    randomInt( 0, canvas.width ),
                    randomInt( 0, canvas.height ) )

                // b.Velocity.fromAngle( randomAngle(), 4 ).scale( 0.5 )
                b.Velocity.fromAngle( randomAngle(),
                    randomNumber( maxVel / 10, maxVel ) )

                if( appConfig.spawnWithMass ) {
                    if ( b.Radius > 20 ) { b.Velocity.scale( 0.3 ) } else { b.Velocity.scale( 4 ) }
                }

                b.Steer.fromAngle( toRadians( 0 ), 1 )
                b.Steer.fromCoord( 0, 0 )

                entityList.push( b )
            }
            console.info( `spawned ${i} boids` )
            debugLogBoidStates( entityList, 'table' )
            requestAnimationFrame( updateGameStep )
        }
        function updateGameStep ( timestamp ) {
            // todo: ensure timestep is increased by a fixed timestep to ensure stable physics simulations
            if ( start === undefined ) {
                start = timestamp;
            }
            const elapsed = timestamp - start;
            const timestepMod = ( elapsed ) / 1000
            const maxVel = appConfig.maxVelocityForce

            for ( const b of entityList ) {
                const steer = calculateSeekForce( b, appConfig.lastMousePos )
                b.Steer.fromVector( steer.limit(0.001) )  //.limit( 0.00001 )
                b.Velocity.fromVector( b.Velocity.limit( maxVel ) )

                if( appConfig.disableSeeking == true ) {
                    b.Steer.fromCoord( 0.0, 0.0 )
                }
                b.update()
            }
            BounceScreenEdge( entityList, canvas )

            drawCanvas()
            // console.info(timestamp)
            requestAnimationFrame( updateGameStep )
        }


        function calculateSeekForce( boid, target ) {
            const boid_maxSteer = appConfig.maxSteerForce || 0.0001
            const desired = target.clone()
                .subtract( boid.Position )
                // .normalize()
                .limit( boid_maxSteer )
                // .normalize().scale( boid_maxSteer )

            // const steer = desired.subtract( boid.Velocity ).limit( 0.1 ) // boid.MaxForce )
            const steer = desired
            return steer
        }

        // section: register events
        window.addEventListener( "load", InitializePage )
        canvas.addEventListener( 'click', ( e ) => {
            InitializePage()
        } )
        document.getElementById( 'btn-draw-vector' ).textContent = appConfig.drawVectors ? 'Hide Vectors' : 'Show Vectors'
        document.getElementById( 'btn-disable-steer' ).textContent = appConfig.disableSeeking ? 'Enable Steering' : 'Disable Steering'

        const input_maxInitVelocity = document.getElementById( 'max-init-velocity' )
        const output_maxInitVelocity = document.querySelector( '.max-init-velocity-output' )
        const input_steerForce = document.getElementById( 'max-steer-force' )
        const output_steerForce = document.querySelector( '.max-steer-force-output' )
        const input_velocityForce = document.getElementById( 'max-velocity-force' )
        const output_velocityForce = document.querySelector( '.max-velocity-force-output' )

        // sync initial text states
        output_maxInitVelocity.textContent = input_maxInitVelocity.value;
        output_steerForce.textContent = input_steerForce.value;
        output_velocityForce.textContent = input_velocityForce.value;
        appConfig.maxSteerForce = parseFloat( input_steerForce.value )
        appConfig.maxVelocityForce = parseFloat( input_velocityForce.value )
        appConfig.maxSteerForce = parseFloat( input_steerForce.value )

        input_velocityForce.addEventListener( "input", () => {
          output_velocityForce.textContent = input_velocityForce.value;
          appConfig.maxVelocityForce = parseFloat( input_velocityForce.value )
          InitializePage()
        })

        input_maxInitVelocity.addEventListener( "input", () => {
          output_maxInitVelocity.textContent = input_maxInitVelocity.value;
          appConfig.spawnMaxVelocity = parseFloat( input_maxInitVelocity.value )
          InitializePage()
        })
        input_steerForce.addEventListener( "input", () => {
          output_steerForce.textContent = input_steerForce.value;
          appConfig.maxSteerForce = parseFloat( input_steerForce.value )
          InitializePage()
        })

        document.getElementById( 'btn-draw-vector' ).addEventListener( 'click', ( e ) => {
            appConfig.drawVectors = ! appConfig.drawVectors
            e.target.textContent = appConfig.drawVectors ? 'Hide Vectors' : 'Show Vectors'
        } )
        document.getElementById( 'btn-disable-steer' ).addEventListener( 'click', ( e ) => {
            appConfig.disableSeeking = ! appConfig.disableSeeking
            e.target.textContent = appConfig.disableSeeking ? 'Enable Steering' : 'Disable Steering'
        } )

        canvas.addEventListener( 'mousemove', ( e ) => {
            const rect = canvas.getBoundingClientRect()
            const mouseX = e.clientX - rect.left
            const mouseY = e.clientY - rect.top
            const mousePos = new Vector2(mouseX, mouseY)
            // mousePos.fromCoord( 100, 100 )
            const desired = mousePos.clone()

            appConfig.lastMousePos = mousePos


            for ( const b of entityList ) {
                const target = mousePos.clone()
                // const desired_velocity = target
                //     .subtract( b.Position )
                //     .normalize()
                //     .scale( 0.5 ) // max speed

                // const steer = desired_velocity.clone()
                //     .subtract( b.Velocity )
                //     .limit( 0.1 ) // max force
                // const steer = target
                // b.Steer.fromVector( steer )
/*
    desired_velocity = normalize (position -
        target) * max_speed
        steering = desired_velocity - velocity
*/
                // const desired = mousePos.clone()
                //     .subtract( b.Position )
                //     .normalize()
                //     .scale( 0.5 ) // max speed
                // b.Steer.fromCoord( -10, 10 ).normalize().scale(  1 )

                // const steer = mousePos.clone()
                // //     .subtract( b.Velocity )
                // //     .limit( 0.1 ) // max force

                // b.Steer.fromVector( steer )
                // b.Velocity.add( steer )
                // b.Velocity.limit( 3 ) // max speed
            }
            // console.log( { mouseX, mouseY } )

            // console.info( { kind: 'mousemove', evt: e, mouseX, mouseY } )
            // for ( const b of entityList ) {
            //     const desired = new Vector2().fromCoord( mouseX, mouseY )
            //         .subtract( b.Position )
            //         .normalize()
            //         .scale( 0.5 ) // max speed

            //     const steer = desired.clone()
            //         .subtract( b.Velocity )
            //         .limit( 0.1 ) // max force

            //     b.Velocity.add( steer )
            //     // b.Velocity.limit( 3 ) // max speed
            // }
        } )

        window.bag.ctx = ctx
        window.bag.ents = entityList // might go out of sync if re-assigned
        console.trace( 'debug enabled globals: ', { bag } )
        console.info( 'Using Context Attrs', ctx.getContextAttributes() )
    </script>
</body>

</html>